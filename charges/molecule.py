import os
import itertools
import re

import numpy as np
from copy import deepcopy

from charges.exceptions import InputError
from charges.utils import int_if_close, atomic_number_to_symbol, symbol_to_atomic_number


class Atom(object):
    """
    A container for basic properties for an atom.
    """

    def __init__(self, label, atomic_number, charge, position=None):
        self.label = label
        self.atomic_number = atomic_number
        self.symbol = atomic_number_to_symbol(atomic_number)
        self.charge = charge
        self.position = np.array(list(map(float, position)), dtype=np.int32)

    def __repr__(self):
        if self.charge > 0:
            charge_str = "{0}+".format(self.charge)
        elif self.charge < 0:
            charge_str = "{0}-".format(abs(self.charge))
        else:
            charge_str = "neutral"

        return "<{0} ({1})>".format(self.symbol, charge_str)

    def __eq__(self, other):
        if isinstance(other, Atom):
            return other.atomic_number == self.atomic_number
        elif isinstance(other, int):
            return self.atomic_number == int

    @classmethod
    def copy(cls, atom):
        """Construct a deep copy of an ``Atom`` object.

        :type atom: :class:`charges.molecule.Atom`
        :param atom: An instance of ``Atom`` to be copied.
        :rtype: :class:`charges.molecule.Atom`
        :return: A deep copy of the input ``Atom``.
        """
        return cls(atom.label, atom.atomic_number, atom.charge,
                   deepcopy(atom.position))

    @classmethod
    def from_ac_line(cls, ac_line_string):
        """
        Construct an ``Atom`` object from a line of ``.ac`` file generated by the AnteChamber tool.

        :type ac_line_string: str
        :param ac_line_string: A single, unmodified line from a AnteChamber format file,
            which starts with the word `ATOM`.
        :return: The ``Atom`` object representation filled with information extracted from input.
        """
        segments = ac_line_string.split()
        label, atom_str = segments[1:3]
        position = np.array(segments[5:8])
        charge = int_if_close(float(segments[8]))

        # Atom description in the format of Symbol + Label, e.g. N1, C2, etc.
        # Extract atom symbol by regex
        symbol = re.findall(r'[A-Z][a-z]?', atom_str)[0]
        return cls(label, symbol_to_atomic_number(symbol), charge, position=position)


class Bond(object):
    """
    A container for basic properties for a bond. Refers to instances of the :class:`Atom` object.
    """

    def __init__(self, *bonding_atoms, bond_order=1):
        self.bonding_atoms = bonding_atoms
        self.bond_order = bond_order

    @classmethod
    def copy(cls, bond, all_atoms):

        def find_atom_by_label(label, atoms):
            for _ in atoms:
                if label == _.label:
                    return _
            return None

        return cls(*[find_atom_by_label(atom.label, all_atoms) for atom in bond.bonding_atoms],
                   bond_order=bond.bond_order)

    @classmethod
    def from_ac_line(cls, ac_line_string, all_atoms):
        """
        Construct a ``Bond`` object from a line of ``.ac`` file generated by the AnteChamber tool.

        :type ac_line_string: str
        :param ac_line_string: A single, unmodified line from a AnteChamber format file,
            which starts with the word `BOND`.
        :type all_atoms: [Atom, ...]
        :param all_atoms: A list of :class:charges.molecule.Atom objects.
            Order of the atoms must confer to the order labelled by the AnteChamber file format.
        :return: The ``Bond`` object representation filled with information extracted from input.
        """
        segments = ac_line_string.split()
        bonding_atom_labels = segments[2:4]
        bond_order = int(segments[4])
        return cls(*[all_atoms[int(label) - 1] for label in bonding_atom_labels],
                   bond_order=bond_order)


class Molecule(object):
    def __init__(self, atoms, bonds=None, name=None, charge=0):
        self.atoms = atoms
        self.bonds = bonds
        self.name = name
        self.charge = charge

    def __repr__(self):
        d = {
            'name': self.name,
            'no_atoms': len(self.atoms),
        }
        if len(self.atoms) > 1:
            d['no_atoms'] = "{0} atoms".format(d['no_atoms'])
        else:
            d['no_atoms'] = "1 atom"

        return "<Molecule: {name}, {no_atoms}>".format(**d)

    def __len__(self):
        return len(self.atoms)

    @classmethod
    def copy(cls, molecule):
        atoms = [Atom.copy(atom) for atom in molecule.atoms]

        if len(molecule.bonds) > 0:
            bonds = [Bond.copy(bond, atoms) for bond in molecule.bonds]
        else:
            bonds = None

        return cls(atoms, bonds, molecule.name, molecule.charge)

    @classmethod
    def from_ac_file(cls, ac_file_name, **kwargs):
        with open(ac_file_name, 'r') as f:
            lines = f.readlines()
        atom_lines, bond_lines = [], []
        for line in lines:
            if 'ATOM' in line:
                atom_lines.append(line)
            elif 'BOND' in line:
                bond_lines.append(line)

        # Read charge from first line
        # prefer integer if within 0.01 of a whole number
        charge = int_if_close(
            float(lines.pop(0).split()[1])
        )

        # Read atoms
        atoms = []
        for atom_line in atom_lines:
            atoms.append(Atom.from_ac_line(atom_line))

        # Read bonds
        bonds = []
        for bond_line in bond_lines:
            bonds.append(Bond.from_ac_line(bond_line, atoms))

        return cls(atoms, bonds=bonds, charge=charge, **kwargs)

    @classmethod
    def from_cube_header(cls, header_lines, *args, **kwargs):
        atoms = []
        for index, line in enumerate(header_lines):
            segments = line.split()
            atomic_number = int(segments[0])
            atoms.append(Atom(index+1, atomic_number,
                              charge=int_if_close(float(segments[1]) - atomic_number),
                              position=np.array(list(map(float, segments[2:])), dtype=np.int32))
                         )
        return cls(atoms, *args, **kwargs)

    def select_label(self, *labels):
        try:
            if len(labels) == 1:
                return self.atoms[labels[0]-1]
            else:
                return zip([self.atoms[label-1] for label in labels])
        except IndexError:
            raise InputError('Label number argument is larger than the number of atoms contained in this molecule.')


class MoleculeWithCharge(Molecule):
    all_sampling_schemes = {
        'CHelpG': ["(full, chelpg)", "chelpg"],
        "MK": ["(full, mk)", "mk", "merz", "kollman"],
        "CHelp": ["(full, chelp)", "chelp"],
        "MK-UFF": ["(full, mkuff)", "mkuff", "mk-uff", "mk_uff",],
    }
    all_charge_methods = {
        'NBO': ['nbo', 'natural'],
        'Mulliken': ['mulliken', 'm√ºlliken'],
        "ESP": ['esp', 'potential', 'electrostatic'] + list(
            itertools.chain.from_iterable(all_sampling_schemes.values())
        ),
    }

    def __init__(self, charge_file_name, atoms,
                 charge_method=None,
                 sampling_scheme=None,
                 is_restrained=None, is_averaged=None, is_equivalenced=None, is_compromised=None,
                 *args, **kwargs):
        self.charge_file_name = charge_file_name

        self.guess_charge_method(charge_file_name)

        if charge_method is not None:
            self.charge_method = charge_method
        if sampling_scheme is not None:
            self.sampling_scheme = sampling_scheme
        if is_restrained is not None:
            self.is_restrained = is_restrained
        if is_averaged is not None:
            self.is_averaged = is_averaged
        if is_equivalenced is not None:
            self.is_equivalenced = is_equivalenced
        if is_compromised is not None:
            self.is_compromised = is_compromised

        super(MoleculeWithCharge, self).__init__(atoms, *args, **kwargs)

    def guess_charge_method(self, file_name):
        file_name = os.path.splitext(file_name)[0].lower()

        self.is_averaged = "compromise" in file_name
        self.is_restrained = "resp" in file_name or "restrain" in file_name
        self.is_equivalenced = "equivalence" in file_name or self.is_restrained
        self.is_compromised = "compromise" in file_name

        found = False
        for sampling_scheme_name, sampling_scheme_identifiers in self.all_sampling_schemes.items():
            for sampling_scheme_identifier in sampling_scheme_identifiers:
                if sampling_scheme_identifier.lower() in file_name:
                    self.sampling_scheme = sampling_scheme_name
                    found = True
                    break
            if found:
                break

        found = False
        for charge_method, charge_method_identifiers in self.all_charge_methods.items():
            for charge_method_identifier in charge_method_identifiers:
                if charge_method_identifier.lower() in file_name:
                    self.charge_method = charge_method
                    found = True
                    break
            if found:
                break

    @classmethod
    def from_plaintext_list(cls, file_name_full, base_molecule, *args, **kwargs):
        with open(file_name_full, 'r') as f:
            line = f.read()

        if len(line.split()) != len(base_molecule):
            raise InputError('The list-formatted charge file must have the same number of list as the base molecule. '
                             'The base molecule (.ac file?) may point to a different molecule than this charges list.')

        molecule = Molecule.copy(base_molecule)
        charge = 0
        for atom, charge_str in zip(molecule.atoms, line.split()):
            atom.charge = int_if_close(float(charge_str))
            charge += float(charge_str)

        return cls(file_name_full, molecule.atoms, bonds=molecule.bonds,
                   charge=int_if_close(charge), name=molecule.name, *args, **kwargs)

    @classmethod
    def mulliken_from_gaussian_log(cls, file_name_full, base_molecule):
        pass

    @classmethod
    def from_file(cls, file_name_full, base_molecule, *args, **kwargs):
        file_name, extension = os.path.splitext(file_name_full)

        parsers = {
            '.txt': cls.from_plaintext_list,
        }
        parser_function = parsers.get(extension.lower())
        if parser_function is not None:
            return parser_function(file_name_full, base_molecule, *args, **kwargs)
